#!/opt/perl/bin/perl

#
# Test the solutions. Either call it with the directory name you
# want to test in, or call it as "../test.pl" from within the directory.
#

use 5.032;

use strict;
use warnings;
no  warnings 'syntax';

use experimental 'signatures';
use experimental 'lexical_subs';

use Test::More;
use DBI;
use Getopt::Long;
use Config::Any;

#
# Read options
#
GetOptions 'slow'              =>  \my $run_slow_tests,
           'lang|language=s'   =>  \my @languages,
           'ch|challenges=i'   =>  \my @challenges,
;

my $PERL_WEEKLY_CHALLENGE = 1;
my $ADVENT_OF_CODE        = 2;
my $GOLF                  = 3;
my $KEY_LANGUAGES         = "languages";
my $KEY_TYPE              = "type";
my $KEY_INPUTS            = "input";
my $KEY_CHALLENGES        = "challenges";
my $INDEX_SOURCE          =  0;
my $INDEX_TESTS           =  1;

################################################################################
#
# First, figure out what kind of challenge we are dealing with.
#
################################################################################

my $pwd = `pwd`;
my $dir;
my $type;
if ($pwd =~ m {/GitHub/}p) {
    $dir = ${^POSTMATCH};
    if ($dir =~ m {Programming_Challenges/perlweeklychallenge-club}) {
        $type = $PERL_WEEKLY_CHALLENGE;
    }
    if ($dir =~ m {AdventOfCode20[0-9]{2}/}) {
        $type = $ADVENT_OF_CODE;
    }
    if ($dir =~ m {Golf/StackExchange/}) {
        $type = $GOLF;
    }
}
die "Cannot figure out what we are testing" unless defined $type;


################################################################################
#
# Go to the appropriate directory, if needed.
#
################################################################################

if ($type == $PERL_WEEKLY_CHALLENGE) {
    my $target_file = "README.md";
    #
    # Should be in a directory with README.md
    #
    chdir ".." if -f "../$target_file";
    die "Cannot figure out where we should go" unless -f $target_file;
}
elsif ($type == $ADVENT_OF_CODE) {
    #
    # Should be in Day_NN directory
    #
    die "Cannot figure out where we should go"
         unless $dir =~ m {/Day_[012][0-9]$};
}
elsif ($type == $GOLF) {
    #
    # Check we're in an appropriate directory
    #
    die "Cannot figure out where we should go"
         unless $dir =~ m {^[0-9]+_[A-Za-z_]+$};
}

################################################################################
#
# Find the test dir; this is the directory where we find test
# inputs, expected outputs, and configurations files. This
# may be the current directory.
#
################################################################################

my $TEST_DIR = $type == $PERL_WEEKLY_CHALLENGE ? "t" : ".";

my $config = load_config ($TEST_DIR);


#
# Figure out the languages and challenges we need to handle.
#
my $todo = calc_todo (config     =>  $config,
                      type       =>  $type,
                      argv       => \@ARGV,
                      languages  => \@languages,
                      challenges => \@challenges);


################################################################################
#
# Iterate over the challenges, and run tests for each of them. 
#
################################################################################

foreach my $challenge (keys @$todo) {
    my $info = $$todo [$challenge] or next;
    next unless $$info [$INDEX_SOURCE];
    my @args = ($config, $type, $challenge, $info);
    if ($type == $PERL_WEEKLY_CHALLENGE || grep {$_} @$todo > 1) {
        subtest "Challenge $challenge" => sub {
            test_challenge (@args);
        }
    }
    else {
        test_challenge (@args);
    }
}


################################################################################
#
# Run tests for a single challenge; this means we iterate over all the
# languages, and run the tests for the specific language.
#
################################################################################

sub test_challenge ($config, $type, $challenge, $info) {
    my $sources = $$info [$INDEX_SOURCE];
    my $tests   = $$info [$INDEX_TESTS];

    #
    # Iterate over the languages to be tested
    #
    my @languages = sort keys %$sources;
    foreach my $language (@languages) {
        my @args = ($config, $type, $challenge,
                    $language, $$sources {$language}, $tests);
        if ($type == $PERL_WEEKLY_CHALLENGE ||
            $type == $GOLF                  ||
            @languages > 1) {
            subtest $$config {$KEY_LANGUAGES} {$language} {name} => sub {
                test_language (@args);
            }
        }
        else {
            test_language (@args);
        }
    }
}


done_testing;
exit;

#
# Find a specific setting; the first defined one of:
#   - For a specific input/language
#   - For a specific input
#   - For a specific challenge
#   - For a specific language
#
my sub setting ($config, $key, $type, $challenge, $language, $input) {
    $$config                   {$input} {$language} {$key}  //
    $$config                   {$input}             {$key}  //
    $$config {$KEY_CHALLENGES} {$challenge}         {$key}  //
    $$config {$KEY_LANGUAGES}  {$language}          {$key}  //
    undef;
}

#
# Given a challenge type, a challenge round (if any), and a language,
# return the file we expect the source to be in.
#
my sub source ($config, $type, $challenge, $language) {
    my $source = $$config {$KEY_TYPE} {$type} {source};
    my $ext    = $$config {$KEY_LANGUAGES} {$language} {ext};
    my $dir    = $$config {$KEY_LANGUAGES} {$language} {dir};

    $source =~ s/\Q%{dir}/$dir/gr
            =~ s/\Q%{ext}/$ext/gr
            =~ s/\Q%{challenge}/$challenge/gr;
}


#
# Return the set of inputs, given a challenge and type.
#
my sub inputs ($config, $type, $challenge) {
    my   $pattern = $$config {$KEY_TYPE} {$type} {glob_input};
    glob $pattern =~ s/\Q%{challenge}/$challenge/gr;
}

################################################################################
#
# Run the tests for a specific challenge/language
#
# $in_outputs: hash, keyed by input name (1, 1-1, etc); values
#              are two element arrays, an input file, and an expected
#              output file.
#
################################################################################

sub test_language ($config, $type, $challenge,
                   $language, $source, $in_outputs) {

    my $lang_info = $$config {$KEY_LANGUAGES} {$language};

    if ($language eq 'sql') {
        #
        # Not yet
        #
        ...
    }

    my $compiler = $$lang_info {comp};
    my $compiled = $source . "_out";
    if ($compiler) {
        system $compiler, "-o", $compiled, $source and do {
            fail "Failed to compile $source";
            return;
        }
    }

    foreach my $input (sort keys %$in_outputs) {
        SKIP: {
            #
            # Nothing special for now.
            #
            my @setting_args = ($type, $challenge, $language, $input);
            my $skip      = setting ($config, "skip", @setting_args);
            skip $skip, 1 if $skip;

            my $exe       = setting ($config, "exe",      @setting_args);
            my $args      = setting ($config, "args",     @setting_args) // [];
            my $exe_args  = setting ($config, "exe_args", @setting_args) // [];
            my ($input_file, $output_file) = @{$$in_outputs {$input}};

            my $command;
            if ($compiler) {
                $command = "./$compiled @$args < $input_file";
            }
            else {
                $command = "$exe @$exe_args $source @$args < $input_file";
            }

            my $exp_out   = `cat $output_file`;
            my $got_out   = `$command`;

            #
            # Trim output of leading/trailing whitespace.
            #
            my $trim = setting ($config, "trim", @setting_args);
            unless (defined $trim && !$trim) {
                s/^\h+//m, s/\h+$//m for $exp_out, $got_out;
            }

            is $got_out, $exp_out, $$config {names} {$input} // $input_file;
        }
    }

    if ($compiler && -f $compiled) {
        unlink $compiled;
    }
}


#
# Parse the tables SQL, extract the table names, and the column names,
# *EXCLUDING* any primary key of the form "integer PRIMARY KEY"
# We're assuming some sane formatting (one column per line).
#
# Returns an array of arrays. Each (inner) array consists of a table
# name, followed by the name of the columns of that table.
#
# We will also create the database handle, use it to create the tables,
# and return the database handle as a second value.
#
sub init_sql ($query_file, $tables_file) {
    my $query  = `cat $query_file`;
    my $tables = -f $tables_file ? `cat $tables_file` : "";

    my $in_table = 0;
    my @info;
    foreach (split /\n/ => $tables) {
        if (!$in_table) {
            if (/^\s* CREATE \s+ TABLE \s+ (\w+)/xi) {
                $in_table = 1;
                push @info => [$1];
            }
            next;
        }
        else {
            if (/^\s* \)/x) {
                $in_table = 0;
                next;
            }
            # Any other line is a column definition
            next if /^ \s* \w+ \s+ integer \s+ PRIMARY \s+ KEY \s*,/xi;
            if (/^ \s* (\w+)/x) {
                push @{$info [-1]} => $1;
            }
        }
    }
    #
    # Does the query have place holders?
    #
    if ($query =~ /\?/) {
        push @info => ["Placeholder"];
    }

    my $dbh = DBI:: -> connect ("dbi:SQLite:dbname=:memory:", "", "",
                                {RaiseError   =>  1,
                                 PrintError   =>  1,
                                 AutoCommit   =>  1});
    $dbh -> do ($tables) if $tables;

    return ($dbh, $query, \@info);
}


sub test_sql ($dbh, $query, $tables_info, $input) {
    #
    # For now, assume we each set of N lines, where N is the number of tables
    # is a test. We also assume that if a line has P items (space separated),
    # and the corresponing table has Q columns (not counting any integer primary
    # keys, as SQLite fills them automatically), we have to fill int (P/Q) rows.
    #

    #
    # Read the input, if any
    #
    my @input;
    if (-f $input) {
        open my $i_fh, "<", $input or die "Failed to open $input: $!";
        @input = <$i_fh>;
    }

    my $output = "";

  TEST:
    while (@input >= @$tables_info) {
        my $real_query = $query;
        foreach my $table_info (@$tables_info) {
            my ($table, @fields) = @$table_info;
            my $input            = shift @input;
            my @values           = split ' ' => $input;
            last TEST if @values < @fields && $table ne "Placeholder";

            #
            # Handle place holder queries
            #
            if ($table eq "Placeholder") {
                $real_query =~ s/\?/shift @values/eg;
                next;
            }

            #
            # Clear the table
            #
            $dbh -> do ("DELETE FROM $table");

            #
            # Construct an input query
            #
            my $place  = "(" . join (", " => ("?") x @fields) . ")";
            my $insert = do {local $" = ", "; <<~ "--"};
                INSERT
                  INTO  $table
                       (@fields)
                VALUES  @{[($place) x (@values / @fields)]}
            --

            $dbh -> do ($insert, undef, @values);
        }


        #
        # Run the query. If we have multiple results, join columns
        # by spaces, and rows by newlines.
        #
        foreach my $query (split /^\s*;\s*$/m => $real_query) {
            my $result = $dbh -> selectall_arrayref ($query);
            $output   .= join "\n" => map {join " " => @$_} @$result;
            $output   .= "\n";
        }

        last unless @input;
    }

    $output;
}

################################################################################
#
# Load any configuration files; for now, we are assuming there is only
# one configuration file. Note that load_stems returns an array ref of 
# configuration hashes, of which the (single) key is the name of the
# configuration file; so we're getting the first element of the array
# ref, and take the first element of the list of values returned.
#
################################################################################

sub load_config ($conf_dir) {
    my $all_config = Config::Any::
                          -> load_stems ({stems   => ["$conf_dir/ctest"],
                                          use_ext => 1});

    my $config = (values %{$$all_config [0]}) [0];

    #
    # Split any compound sections; we only handle one level deep.
    #
    foreach my $key (keys %$config) {
        $key =~ m{[/,]} or next;
        my $info = delete $$config {$key};
        my ($major, $minor) = split '/' => $key;
        foreach my $sub_major (split /,\s*/ => $major) {
            if ($minor) {
                foreach my $sub_minor (split /,\s*/ => $minor) {
                    $$config {$sub_major} {$sub_minor} = $info;
                }
            }
            else {
                $$config {$sub_major} = $info;
            }
        }
    }

    load_language_config ($config);
    load_type_config     ($config);

    $config;
}

#
# Load the language info. 
#

sub load_language_config ($config) {
    my $HOME = $ENV {HOME};
    my $KEY  = "languages";

    my %languages = (
        awk          =>   {
            exe      =>   "/usr/bin/awk",
            exe_args =>   ["-f"],
        },
        Bash         =>   {
            ext      =>   "sh",
            exe      =>   "/bin/sh",
        },
        BASIC        =>   {
            ext      =>   "bas",
            exe      =>   "$HOME/Bin/run-language",
        },
        bc           =>   {
            exe      =>   "/usr/bin/bc",
            filter   =>   's/.*/main($&)/',
        },
       'Befunge-93'  =>   {
            ext      =>   "bf93",
            exe      =>   "$HOME/Bin/run-language",
        },
       'Brainfuck'   =>   {
            ext      =>   "bf",
            exe      =>   "$HOME/Bin/brainfuck",
        },
        C            =>   {
            comp     =>   "/usr/bin/cc",
        },
        Chef         =>   {
            exe      =>   "/opt/perl/bin/chef",
        },
        Cobol        =>   {
            ext      =>   "cb",
            exe      =>   "TIO",
        },
        Csh          =>   {
            exe      =>   "/bin/csh",
        },
        Forth        =>   {
            ext      =>   "fs",
            exe      =>   "TIO",   # Could no build gforth
        },
        Fortran      =>   {
            ext      =>   "f90",
            comp     =>   "/opt/local/bin/gfortran-mp-4.4",
        },
        MUMPS        =>   {
            ext      =>   "mps",
            exe      =>   "TIO",   # Language::Mumps is really broken
        },
        Node         =>   {
            name     =>   'Node.js',
            exe      =>   "/usr/local/bin/node",
            ext      =>   "js",
            dir      =>   "node",
        },
       'Ook!'        =>   {
            exe      =>   "$HOME/Bin/ook",
        },
        Pascal       =>   {
            ext      =>   "p",
            exe      =>   "TIO",
        },
        Perl         =>   {
            exe      =>   "/opt/perl/bin/perl",
            ext      =>   "pl",
        },
        Python       =>   {
            ext      =>   "py",
            exe      =>   "/opt/local/bin/python",
        },
        Ruby         =>   {
            ext      =>   "rb",
            exe      =>   "/usr/bin/ruby",
        },
        SQL          =>   {
        },
    );

    #
    # Do we already have language info defined in the config file?
    #
    foreach my $key (keys %$config) {
        next unless $key =~ m {^language/(.*)};
        my $language = lc $1;
        $$config {$KEY} {$language}          = delete $$config {$key};
        $$config {$KEY} {$language} {name} //= $1;
    }

    #
    # Merge; we store the languages in lower case, with non-letters removed.
    #
    foreach my $language (keys %languages) {
        my $lc_language = (lc $language) =~ s/\PL+//gr;
        $languages {$language} {dir}  //= $lc_language;
        $languages {$language} {ext}  //= $lc_language;
        $languages {$language} {name} //=    $language; # Keep original name.
        foreach my $key (keys %{$languages {$language}}) {
            $$config {$KEY} {$lc_language} {$key} //=
                    $languages {$language} {$key};
        }
    }
}



#
# Load type dependent configuration
#
sub load_type_config ($config) {
    $$config {$KEY_TYPE} {$PERL_WEEKLY_CHALLENGE} {source} ||=
                                    "%{dir}/ch-%{challenge}.%{ext}";
    $$config {$KEY_TYPE} {$ADVENT_OF_CODE}        {source} ||=
                                                  "solution.%{ext}";
    $$config {$KEY_TYPE} {$GOLF}                  {source} ||=
                                                  "solution.%{ext}";

    $$config {$KEY_TYPE} {$PERL_WEEKLY_CHALLENGE} {glob_input} ||=
                                           "t/input-%{challenge}-*";
    $$config {$KEY_TYPE} {$ADVENT_OF_CODE}        {glob_input} ||=
                                                          "input-*";
    $$config {$KEY_TYPE} {$GOLF}                  {glob_input} ||=
                                                          "input-*";

}



#
# Return a structure of things we need to process.
# This will be an array ref; each element a challenge.
# Each challenge will have a list of languages to process,
# and a set of inputs/outputs.
#
#    [
#        [language1, language2, ...],
#        {
#            test1 => [input_file1, output_file1],
#            test2 => [input_file2, output_file2],
#            ...,
#        },
#        ...
#    ]
#
#
#
sub calc_todo (%args) {
    my $config     = $args {config};
    my $type       = $args {type};
    my $argv       = $args {argv} || [];

    #
    # Find the default set of challenges:
    #   -  If passed on as options, use them,
    #   -  Else, grep anything looking like a number from @ARGV,
    #   -  Else, use 1 .. 2, or just 1.
    #
    my $challenges = $args {challenges} ?  [grep {/^[1-9][0-9]*$/}
                                                @{$args {challenges}}]
                                        :  [];
    if (!@$challenges) {
        $challenges = [grep {/^[1-9][0-9]*$/} @$argv];
        $challenges = $type == $PERL_WEEKLY_CHALLENGE ? [1 .. 2] : [1]
                                unless @$challenges;
    }


    #
    # Find the default set of languages:
    #   -  If passed on as options, use them,
    #   -  Else, grep anything which looks like a language from @ARGV,
    #   -  Else, use languages from the configuration.
    #
    my $languages  = $args {languages}  ?  [map  {lc ($_) =~ s/\PL+//gr}
                                                @{$args {languages}}]
                                        :  [];

    if (!@$languages) {
        #
        # If we don't have any languages passed in, see whether there
        # is something on @ARGV which looks like a language; if so, use it.
        #
        if ($argv && @$argv) {
           $languages = [grep {$$config {$KEY_LANGUAGES} {$_}}
                         map  {lc ($_) =~ s/\PL+//gr} @$argv];
        }
    }
    #
    # Still nothing? Get the list from the config
    #
    $languages = [keys %{$$config {$KEY_LANGUAGES}}] unless @$languages;

    #
    # Now, find solutions.
    #
    my @out;

    foreach my $language (@$languages) {
        my $ext = $$config {$KEY_LANGUAGES} {$language} {ext};
        my $dir = $$config {$KEY_LANGUAGES} {$language} {dir};
        foreach my $challenge (@$challenges) {
            my $source = source $config, $type, $challenge, $language;
            if (-f $source) {
                $out [$challenge] [$INDEX_SOURCE] {$language} = $source;
            }
            my @inputs = inputs $config, $type, $challenge;
            foreach my $input (@inputs) {
                $input =~ /input-/p;  ## FIXME
                my $name = ${^POSTMATCH};
                my $output  = $input =~ s/input/output/r;
                   $output .= ".exp";
                $out [$challenge] [$INDEX_TESTS] {$name} = [$input, $output];
            }
        }
    }

    \@out;
}


__END__

=pod

my $todo_challenges;
my $todo_languages;
my %languages = %{$$config {languages}};  ## FIX ME

my $perl_exe = $languages {perl} {exe};

foreach my $challenge (@$todo_challenges) {
    my ($dbh, $query, $tables_info);   # Only for SQL tests.

    my @outputs = <t/output-$challenge-*> or next;
    subtest "Challenge $challenge" => sub {
        foreach my $language (@$todo_languages) {
            my $info      =   $$config {$KEY_LANGUAGES} {$language};
            my $exe       =   $$info {exe};
            my $ext       =   $$info {ext};
            my $comp      =   $$info {comp};
            my $dir       =   $$info {dir}     // lc $language;
            my @args      = @{$$info {args}    // []};
            my $filter    =   $$info {filter}  // '';
            my $ext_out   =   $$info {ext_out} // "out";
            my $source    =  "$dir/ch-$challenge.$ext";
            my $lang_name =   $$info {name};
            my $compiled;
            next unless -r $source;

            subtest $lang_name => sub {
              SKIP: {
                if ($exe && $exe eq "TIO") {
                    skip "No executable present, please use tio.net", 1;
                }

                #
                # Some languages first need to be compiled.
                #
                if ($comp) {
                    $compiled = $source =~ s/\.$ext$/.$ext_out/r;
                    system $comp, "-o", $compiled, $source;
                }

                #
                # SQL requires requires creating an in-memory database,
                # and loading some tables. For that, we need a .tables
                # file. We also read the actual query at this time.
                #
                if ($language eq "SQL") {
                    my $tables = $source =~ s/\.\Q$ext\E$/.table/r;
                   ($dbh, $query, $tables_info) = init_sql ($source, $tables);
                }

                foreach my $output_exp (@outputs) {
                  SKIP: {
                    my $input      = $output_exp =~ s/output/input/r
                                                 =~ s/\.exp$//r;
                    my $exp        = `cat $output_exp`;
                    my $run        = $input =~ s/^.*\binput-//r;

                    my $name = $input;

                    run_test ($config, $PERL_WEEKLY_CHALLENGE, 1, "perl",
                              {"1-1" => [$input, $output_exp],
                               "1-2" => [$input, $output_exp]});

                    if (!-f $input) {
                        $name  = "No input";
                        $input = "/dev/null";
                    }

                    my %pragma;
                    my @options;

                    while ($exp =~ s/^\s*#%\s*(.*)\n//) {
                        my $pragma = $1;
                        $pragma =~ s/\s+$//;
                        if ($pragma =~ s/^\@(\S+)\s*//) {
                            next unless lc ($1) eq lc ($language);
                        }
                        if ($pragma =~ /^[-\w]+$/) {
                            $pragma {lc $pragma} = 1;
                            next;
                        }
                        if ($pragma =~ /^\s*(\w+):\s*(.*)/) {
                            my ($key, $value) = ($1, $2);
                            if (lc $key eq "opt") {
                                push @options => $value;
                            }
                        }
                    }

                    if ($$config {names} {$run}) {
                        $name = $$config {names} {$run};
                    }

                    if ($exp =~ s/^\s*#\s*(.*)\n//) {
                        $name = $1;
                    }

                    skip "Skipping slow test", 1
                        if $pragma {slow} && !$run_slow_tests;

                    my $got;
                    if ($compiled) {
                        $got = `$perl_exe -ple '$filter' $input |\
                              ./$compiled @options`;
                    }
                    elsif ($language eq "SQL") {
                        $got = test_sql ($dbh, $query, $tables_info, $input);
                    }
                    else {
                        $got = `$perl_exe -ple '$filter' $input |\
                                $exe @args ./$source @options`;
                    }

                    s/\h+$//gm for $exp, $got;
                    if ($pragma {trim}) {
                        s/^\h+//gm for $exp, $got;
                    }
                    if ($pragma {"swap-pairs"}) {
                        my @got = split /\n/ => $got;
                        for (my $i = 0; $i + 1 < @got; $i += 2) {
                            @got [$i, $i + 1] = @got [$i + 1, $i];
                        }
                        $got = join "\n" => @got, "";
                    }
                    is $got, $exp, $name;
                }}
                unlink $compiled if $compiled;
            }}
        }
    }
}

=cut
